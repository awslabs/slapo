

<!DOCTYPE html>


<html >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>slapo.schedule &#8212; Slapo Documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" href="../../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/slapo/schedule';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="None"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    <p class="title logo__title">Slapo Documentation</p>
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../setup/index.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gallery/quick-start.html">Quick Start</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../gallery/attention-single-gpu.html">Optimize Attention Module on A Single Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gallery/mlp-multi-gpu.html">Optimize MLP Module on Multi-Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gallery/debug-print.html">Debugging with Print</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../python_api/index.html">Python API</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../python_api/root.html">slapo</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../python_api/schedule.html">slapo.schedule</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../python_api/initialization.html">slapo.initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../python_api/pattern.html">slapo.pattern</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../python_api/pipeline.html">slapo.pipeline</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../python_api/tracer.html">slapo.tracer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../python_api/random.html">slapo.random</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../python_api/framework_dialect/index.html">slapo.framework_dialect</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../python_api/framework_dialect/registry.html">slapo.framework_dialect.registry</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../python_api/framework_dialect/deepspeed/index.html">slapo.framework_dialect.deepspeed</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../python_api/framework_dialect/deepspeed/engine.html">slapo.framework_dialect.deepspeed.engine</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../python_api/framework_dialect/deepspeed/pipeline.html">slapo.framework_dialect.deepspeed.pipeline</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../python_api/model_schedule/index.html">slapo.model_schedule</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../python_api/model_schedule/api.html">slapo.model_schedule.api</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../python_api/op/index.html">slapo.op</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-5"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../python_api/op/attention.html">slapo.op.attention</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../python_api/op/cross_entropy.html">slapo.op.cross_entropy</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../python_api/op/fused_bias.html">slapo.op.fused_bias</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../python_api/op/linear.html">slapo.op.linear</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../python_api/op/mlp.html">slapo.op.mlp</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../genindex.html">Index</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://github.com/awslabs/slapo" target="_blank"
   class="btn btn-sm btn-source-repository-button"
   title="Source repository"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <h1>Source code for slapo.schedule</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.</span>
<span class="c1"># SPDX-License-Identifier: Apache-2.0</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Callable</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">FunctionType</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Optional</span>

<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.distributed</span> <span class="k">as</span> <span class="nn">dist</span>
<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">fx</span><span class="p">,</span> <span class="n">nn</span>

<span class="c1"># pylint: disable=unused-import</span>
<span class="kn">import</span> <span class="nn">torch.nn.functional</span> <span class="k">as</span> <span class="nn">F</span>

<span class="kn">from</span> <span class="nn">.logger</span> <span class="kn">import</span> <span class="n">get_logger</span>
<span class="kn">from</span> <span class="nn">.primitives</span> <span class="kn">import</span> <span class="n">PRIMITIVES</span>
<span class="kn">from</span> <span class="nn">.pipeline</span> <span class="kn">import</span> <span class="n">analyze_tie_weights</span>

<span class="kn">from</span> <span class="nn">.tracer</span> <span class="kn">import</span> <span class="n">trace</span> <span class="k">as</span> <span class="n">trace_module</span>
<span class="kn">from</span> <span class="nn">.utils.common</span> <span class="kn">import</span> <span class="n">is_lambda_function</span>
<span class="kn">from</span> <span class="nn">.utils.mapping</span> <span class="kn">import</span> <span class="n">MAPPING_FROM_FUNCTIONAL_TO_MODULE</span>
<span class="kn">from</span> <span class="nn">.pattern</span> <span class="kn">import</span> <span class="n">Pattern</span><span class="p">,</span> <span class="n">ModulePattern</span><span class="p">,</span> <span class="n">call_module</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">get_logger</span><span class="p">()</span>

<span class="c1"># Wrap call_module as a leaf.</span>
<span class="c1"># This is a limitation of torch.fx</span>
<span class="c1"># Currently the leaf function wrapper can only be registered in the same module</span>
<span class="c1"># Otherwise, the wrapper cannot work properly.</span>
<span class="c1"># See https://github.com/pytorch/pytorch/blob/v1.13.1/torch/fx/_symbolic_trace.py#L1011-L1012</span>
<span class="n">fx</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">call_module</span><span class="p">)</span>


<div class="viewcode-block" id="ScheduleMetadata"><a class="viewcode-back" href="../../python_api/schedule.html#slapo.ScheduleMetadata">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">ScheduleMetadata</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;The metadata of a schedule. It is used to store the metadata of</span>
<span class="sd">    primitives and the top module mainly for 1) verification and</span>
<span class="sd">    2) applying framework dialects. Note that when replacing a module,</span>
<span class="sd">    the schedule metadata of the original module is NOT transferred to the</span>
<span class="sd">    new schedule, because the new module may not have the same structure</span>
<span class="sd">    as the original module.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># pylint: disable=unnecessary-lambda</span>

    <span class="c1"># Tie weight analysis only at the top level module.</span>
    <span class="c1"># tie_weights is a mapping from parameter object to the same</span>
    <span class="c1"># parameter object. Note that the value may be changed during</span>
    <span class="c1"># scheduling (e.g., sharding).</span>
    <span class="n">tie_weights</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">nn</span><span class="o">.</span><span class="n">Parameter</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">Parameter</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span>
        <span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">OrderedDict</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="c1"># The set of parameter tags added either by primitives or users.</span>
    <span class="c1"># These tags will be transferred to the new parameter when it is replaced</span>
    <span class="c1"># (e.g., sharding and consolidation).</span>
    <span class="n">param_tags</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">set</span><span class="p">)</span>

    <span class="c1"># Primitive specific metadata.</span>
    <span class="n">primitives</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">OrderedDict</span><span class="p">())</span></div>


<div class="viewcode-block" id="Schedule"><a class="viewcode-back" href="../../python_api/schedule.html#slapo.Schedule">[docs]</a><span class="k">class</span> <span class="nc">Schedule</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mod</span><span class="p">:</span> <span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;Schedule&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">group</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">dist</span><span class="o">.</span><span class="n">ProcessGroup</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">dist</span><span class="o">.</span><span class="n">is_initialized</span><span class="p">():</span>
            <span class="n">world_size</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">get_world_size</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="n">rank</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">world_size</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">rank</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group</span> <span class="o">=</span> <span class="n">group</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">world_size</span> <span class="o">=</span> <span class="n">world_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">=</span> <span class="n">rank</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mod</span> <span class="o">=</span> <span class="n">mod</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">child</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">ScheduleMetadata</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Tie weight analysis only at the top level module.</span>
            <span class="c1"># tie_weights is a mapping from parameter object to the same</span>
            <span class="c1"># parameter object. Note that the value may be changed during</span>
            <span class="c1"># scheduling (e.g., sharding).</span>
            <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">analyze_tie_weights</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">tie_weights</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Inherit tie_weights from parent.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">tie_weights</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">tie_weights</span>

        <span class="c1"># Register primitives.</span>
        <span class="k">for</span> <span class="n">pname</span><span class="p">,</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">PRIMITIVES</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pname</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">apply</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">primitives</span><span class="p">[</span><span class="n">pname</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">init_metadata</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">tokenize_module_path</span><span class="p">(</span><span class="n">module_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">module_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">list_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">tokens</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Invalid module path: </span><span class="si">{</span><span class="n">module_path</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">tokens</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tokens</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">list_idx</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tokens</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">update_submodule</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">submod_name</span><span class="p">,</span> <span class="n">new_submod</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;.&quot;</span> <span class="ow">in</span> <span class="n">submod_name</span><span class="p">:</span>
            <span class="c1"># The submodule is a module list.</span>
            <span class="n">submod_name</span><span class="p">,</span> <span class="n">list_idx</span> <span class="o">=</span> <span class="n">submod_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">submod_name</span><span class="p">)[</span><span class="nb">int</span><span class="p">(</span><span class="n">list_idx</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_submod</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">submod_name</span><span class="p">,</span> <span class="n">new_submod</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_path</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">full_path</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">curr_sch</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenize_module_path</span><span class="p">(</span><span class="n">full_path</span><span class="p">):</span>
            <span class="n">sub_tokens</span> <span class="o">=</span> <span class="n">token</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub_tokens</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">sub_tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">curr_sch</span><span class="o">.</span><span class="n">child</span><span class="p">:</span>
                <span class="c1"># If this token is in the format of &quot;layer.0&quot; and &quot;layer&quot; is</span>
                <span class="c1"># a child of curr_sch, then &quot;layer&quot; is nn.Sequential. In this case,</span>
                <span class="c1"># we have to first get the nn.Sequential module first.</span>
                <span class="n">curr_sch</span> <span class="o">=</span> <span class="n">curr_sch</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="n">sub_tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">token</span> <span class="o">=</span> <span class="n">sub_tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">token</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">curr_sch</span><span class="o">.</span><span class="n">child</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The schedule of &#39;</span><span class="si">{</span><span class="n">full_path</span><span class="si">}</span><span class="s2">&#39; (</span><span class="si">{</span><span class="n">token</span><span class="si">}</span><span class="s2">) is not a child &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;of </span><span class="si">{</span><span class="n">curr_sch</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="n">curr_sch</span> <span class="o">=</span> <span class="n">curr_sch</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="n">token</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">curr_sch</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Module &#39;</span><span class="si">{</span><span class="n">full_path</span><span class="si">}</span><span class="s2">&#39; is not found&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">curr_sch</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_path</span><span class="p">):</span>
        <span class="n">curr_sch</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenize_module_path</span><span class="p">(</span><span class="n">full_path</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">token</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">curr_sch</span><span class="o">.</span><span class="n">child</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="n">curr_sch</span> <span class="o">=</span> <span class="n">curr_sch</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="n">token</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">curr_sch</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">get_top_schedule</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">get_top_schedule</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mod</span><span class="o">.</span><span class="n">named_modules</span><span class="p">())[</span><span class="n">name</span><span class="p">]</span>

<div class="viewcode-block" id="Schedule.named_schedules"><a class="viewcode-back" href="../../python_api/schedule.html#slapo.Schedule.named_schedules">[docs]</a>    <span class="k">def</span> <span class="nf">named_schedules</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns an iterator over all subschedules in the current schedule, yielding</span>
<span class="sd">        both the name of the subschedule as well as the subschedule itself.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">yield</span> <span class="n">prefix</span><span class="p">,</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">subsch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">child</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">subsch_prefix</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;.&quot;</span> <span class="k">if</span> <span class="n">prefix</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">name</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">subsch</span><span class="o">.</span><span class="n">named_schedules</span><span class="p">(</span><span class="n">subsch_prefix</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">m</span></div>

    <span class="k">def</span> <span class="nf">_construct_fx_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subgraph</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct a new fx.Graph based on the subgraph extracted from the</span>
<span class="sd">        original graph. This function should NOT be called directly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        subgraph : List[Tuple[str, Node]]</span>
<span class="sd">            The extracted subgraph from .find() containing the path of the node</span>
<span class="sd">            and the corresponding fx.Node.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fx.Graph</span>
<span class="sd">            The new fx.Graph constructed from the subgraph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#</span>
        <span class="n">new_graph</span> <span class="o">=</span> <span class="n">fx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="c1"># Create input arguments for the new graph</span>
        <span class="n">node_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">value_remap</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">subgraph</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">fx</span><span class="o">.</span><span class="n">Node</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arg</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node_names</span><span class="p">:</span>
                    <span class="n">value_remap</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_graph</span><span class="o">.</span><span class="n">placeholder</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="n">node_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">node_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="c1"># Copy nodes from extracted subgraph to new graph</span>
        <span class="n">mod_mapping</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">subgraph</span><span class="p">:</span>
            <span class="n">value_remap</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_graph</span><span class="o">.</span><span class="n">node_copy</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">value_remap</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;call_module&quot;</span><span class="p">:</span>
                <span class="n">mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_module</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
                <span class="n">mod_mapping</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="n">mod</span>
        <span class="c1"># Return output from new graph</span>
        <span class="n">new_graph</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="n">value_remap</span><span class="p">[</span><span class="n">subgraph</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">new_gm</span> <span class="o">=</span> <span class="n">fx</span><span class="o">.</span><span class="n">GraphModule</span><span class="p">(</span><span class="n">mod_mapping</span><span class="p">,</span> <span class="n">new_graph</span><span class="p">)</span>
        <span class="n">new_gm</span><span class="o">.</span><span class="n">delete_all_unused_submodules</span><span class="p">()</span>
        <span class="n">new_gm</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">eliminate_dead_code</span><span class="p">()</span>
        <span class="n">new_gm</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">lint</span><span class="p">()</span>
        <span class="n">new_gm</span><span class="o">.</span><span class="n">recompile</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">new_gm</span>

<div class="viewcode-block" id="Schedule.find_node"><a class="viewcode-back" href="../../python_api/schedule.html#slapo.Schedule.find_node">[docs]</a>    <span class="k">def</span> <span class="nf">find_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regex_or_pattern_fn</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find a node in a static dataflow graph</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        regex_or_pattern_fn : Union[str, Callable]</span>
<span class="sd">            If this argument is a regular expression, it will only match the</span>
<span class="sd">            `call_module` node whose `target` satisfies the regex;</span>
<span class="sd">            otherwise, it will try to match all the nodes satisfies the</span>
<span class="sd">            pattern function. The pattern_fn should be in `lambda node: ...` format.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[List[Tuple[str, fx.Node]], List[List[Tuple[str, fx.Node]]]</span>
<span class="sd">            Returns all the nodes whose names satisfying the regex,</span>
<span class="sd">            or the nodes satisfying the given pattern constraints.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">regex_or_pattern_fn</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Please pass in a str (regex) or a callable object to describe &quot;</span>
                <span class="s2">&quot;the node pattern&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">mod</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mod</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">fx</span><span class="o">.</span><span class="n">GraphModule</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">mod</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">regex_or_pattern_fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;call_module&quot;</span> <span class="ow">and</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span>
                        <span class="n">regex_or_pattern_fn</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">target</span>
                    <span class="p">):</span>
                        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">regex_or_pattern_fn</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="Schedule.find_subgraph"><a class="viewcode-back" href="../../python_api/schedule.html#slapo.Schedule.find_subgraph">[docs]</a>    <span class="k">def</span> <span class="nf">find_subgraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern_fn</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find a subgraph in a static dataflow graph</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pattern_fn : Union[FunctionType, Pattern]</span>
<span class="sd">            This argument specifies the subgraph pattern.</span>
<span class="sd">            Using a lambda function is easier to specify a pattern, while the `Pattern`</span>
<span class="sd">            class provides the ability to create patterns include submodules.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[List[Tuple[str, fx.Node]]</span>
<span class="sd">            Returns all the subgraphs containing the nodes satisfying the</span>
<span class="sd">            pattern constraints. The outer-most list contains different subgraphs,</span>
<span class="sd">            and the inner list contains the nodes inside a specific subgraph.</span>
<span class="sd">            The inner-most tuple includes the name of the parent module that the node</span>
<span class="sd">            belongs to, and the matched node object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">named_modules</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mod</span><span class="o">.</span><span class="n">named_modules</span><span class="p">())</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">pattern_fn</span><span class="p">,</span> <span class="p">(</span><span class="n">FunctionType</span><span class="p">,</span> <span class="n">Pattern</span><span class="p">)</span>
        <span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_lambda_function</span><span class="p">(</span><span class="n">pattern_fn</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">find_match_subgraphs</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">subgraphs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;output&quot;</span><span class="p">:</span>
                <span class="c1"># &quot;output&quot; always matches.</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">curr</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="n">target</span><span class="o">.</span><span class="n">op</span> <span class="ow">and</span> <span class="n">curr</span><span class="o">.</span><span class="n">target</span> <span class="o">==</span> <span class="n">target</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>  <span class="c1"># exactly match</span>
                <span class="ow">or</span> <span class="p">(</span>  <span class="c1"># nn.Module and nn.functional are viewed as the same</span>
                    <span class="n">curr</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;call_module&quot;</span>
                    <span class="ow">and</span> <span class="n">target</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;call_function&quot;</span>
                    <span class="ow">and</span> <span class="n">MAPPING_FROM_FUNCTIONAL_TO_MODULE</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">named_modules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">curr</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
                <span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span>  <span class="c1"># use pattern language to match</span>
                    <span class="n">curr</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;call_module&quot;</span>
                    <span class="ow">and</span> <span class="n">target</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;call_function&quot;</span>
                    <span class="ow">and</span> <span class="n">target</span><span class="o">.</span><span class="n">target</span> <span class="o">==</span> <span class="n">call_module</span>
                    <span class="ow">and</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">curr</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span>  <span class="c1"># use pattern class for matching</span>
                    <span class="n">curr</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;call_module&quot;</span>
                    <span class="ow">and</span> <span class="n">target</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;call_module&quot;</span>
                    <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">pattern_mod</span><span class="o">.</span><span class="n">named_modules</span><span class="p">())[</span><span class="n">target</span><span class="o">.</span><span class="n">target</span><span class="p">])</span>
                    <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">named_modules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">curr</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
                <span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span>  <span class="c1"># use pattern lanauge + pattern class for matching</span>
                    <span class="n">curr</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;call_module&quot;</span>
                    <span class="ow">and</span> <span class="n">target</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;call_module&quot;</span>
                    <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
                        <span class="nb">dict</span><span class="p">(</span><span class="n">pattern_mod</span><span class="o">.</span><span class="n">named_modules</span><span class="p">())[</span><span class="n">target</span><span class="o">.</span><span class="n">target</span><span class="p">],</span> <span class="n">ModulePattern</span>
                    <span class="p">)</span>
                    <span class="ow">and</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span>
                        <span class="nb">dict</span><span class="p">(</span><span class="n">pattern_mod</span><span class="o">.</span><span class="n">named_modules</span><span class="p">())[</span><span class="n">target</span><span class="o">.</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                        <span class="n">curr</span><span class="o">.</span><span class="n">target</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="p">):</span>
                <span class="c1"># Not matched.</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">parent_name</span><span class="p">,</span> <span class="n">curr</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">subgraphs</span><span class="p">:</span>
                <span class="c1"># New matched.</span>
                <span class="n">subgraphs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">parent_name</span><span class="p">,</span> <span class="n">curr</span><span class="p">))</span>
            <span class="n">matched</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">curr</span><span class="o">.</span><span class="n">next</span> <span class="o">!=</span> <span class="n">curr</span> <span class="ow">and</span> <span class="n">target</span><span class="o">.</span><span class="n">next</span> <span class="o">!=</span> <span class="n">target</span><span class="p">:</span>
                <span class="n">matched</span> <span class="o">=</span> <span class="n">matched</span> <span class="ow">and</span> <span class="n">find_match_subgraphs</span><span class="p">(</span>
                    <span class="n">curr</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">target</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">subgraphs</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">matched</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">pattern_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># pylint: disable=exec-used</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pattern_fn</span><span class="p">,</span> <span class="n">Pattern</span><span class="p">):</span>
                <span class="n">pattern_wrapper</span> <span class="o">=</span> <span class="n">pattern_fn</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># FIXME: Find a safer way to do it</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">pattern_fn</span><span class="p">)</span>
                <span class="n">param_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="n">func_name</span> <span class="o">=</span> <span class="n">pattern_fn</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="n">src_code</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsource</span><span class="p">(</span><span class="n">pattern_fn</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
                <span class="n">closure_vars</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getclosurevars</span><span class="p">(</span><span class="n">pattern_fn</span><span class="p">)</span>
                <span class="n">closure_code</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">closure_vars</span><span class="o">.</span><span class="n">nonlocals</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">closure_code</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">formatted_code</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="n">indent</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">src_code</span><span class="p">:</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                    <span class="k">if</span> <span class="s2">&quot;def&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                        <span class="n">front</span><span class="p">,</span> <span class="n">back</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;(&quot;</span><span class="p">)</span>
                        <span class="n">line</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">indent</span><span class="si">}{</span><span class="n">front</span><span class="si">}</span><span class="s2">(self, </span><span class="si">{</span><span class="n">back</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="n">indent</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="s2">&quot; &quot;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">line</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">indent</span><span class="si">}{</span><span class="n">line</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="n">formatted_code</span> <span class="o">+=</span> <span class="n">line</span>
                <span class="k">if</span> <span class="s2">&quot;.call_module&quot;</span> <span class="ow">in</span> <span class="n">formatted_code</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="s2">&quot;Please directly `from slapo.pattern import call_module`&quot;</span>
                    <span class="p">)</span>
                <span class="n">wrapper_code</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="si">{</span><span class="n">closure_code</span><span class="si">}</span><span class="s2"></span>
<span class="s2">class SubgraphWrapper(nn.Module):</span>
<span class="s2">    def __init__(self):</span>
<span class="s2">        super().__init__()</span>

<span class="s2">    def forward(self, </span><span class="si">{</span><span class="n">param_str</span><span class="si">}</span><span class="s2">):</span>
<span class="s2">        return self.</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">param_str</span><span class="si">}</span><span class="s2">)</span>

<span class="s2">    </span><span class="si">{</span><span class="n">formatted_code</span><span class="si">}</span><span class="s2"></span>
<span class="s2">&quot;&quot;&quot;</span>
                <span class="n">exec</span><span class="p">(</span><span class="n">wrapper_code</span><span class="p">,</span> <span class="nb">globals</span><span class="p">())</span>
                <span class="c1"># pylint: disable=undefined-variable</span>
                <span class="n">pattern_wrapper</span> <span class="o">=</span> <span class="n">SubgraphWrapper</span><span class="p">()</span>
            <span class="n">pattern_mod</span> <span class="o">=</span> <span class="n">trace_module</span><span class="p">(</span>
                <span class="n">pattern_wrapper</span><span class="p">,</span>
                <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">flatten</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">leaf_modules</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;ModulePattern&quot;</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pattern_mod</span><span class="p">,</span> <span class="n">fx</span><span class="o">.</span><span class="n">GraphModule</span><span class="p">)</span>

        <span class="n">first_op</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">target_node</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">pattern_mod</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">):</span>
            <span class="c1"># get the first NON-placeholder,</span>
            <span class="c1"># i.e., the first compute op of the target graph</span>
            <span class="k">if</span> <span class="n">target_node</span><span class="o">.</span><span class="n">op</span> <span class="o">!=</span> <span class="s2">&quot;placeholder&quot;</span><span class="p">:</span>
                <span class="n">first_op</span> <span class="o">=</span> <span class="n">target_node</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot find the first non-placeholder operator&quot;</span><span class="p">)</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">parent_name</span><span class="p">,</span> <span class="n">submod</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mod</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">submod</span><span class="p">,</span> <span class="n">fx</span><span class="o">.</span><span class="n">GraphModule</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">submod</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;placeholder&quot;</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">subgraph</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">target_node</span> <span class="o">=</span> <span class="n">first_op</span>
                <span class="n">curr_node</span> <span class="o">=</span> <span class="n">node</span>
                <span class="k">if</span> <span class="n">find_match_subgraphs</span><span class="p">(</span><span class="n">curr_node</span><span class="p">,</span> <span class="n">target_node</span><span class="p">,</span> <span class="n">subgraph</span><span class="p">):</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subgraph</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="Schedule.find"><a class="viewcode-back" href="../../python_api/schedule.html#slapo.Schedule.find">[docs]</a>    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regex_or_pattern_fn</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find a node or a subgraph in a static dataflow graph.</span>
<span class="sd">        This API is a dispatcher for `find_node` and `find_subgraph`</span>

<span class="sd">        If you need to match a general node pattern, please directly use the `find_node` API.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        regex_or_pattern_fn : Union[str, Callable]</span>
<span class="sd">            A regular expression for specifying the target of `call_module` node, or</span>
<span class="sd">            a callable function/Pattern class specifying the subgraph pattern</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[List[Tuple[str, fx.Node]], List[List[Tuple[str, fx.Node]]]</span>
<span class="sd">            For `find_node`, it returns all the nodes whose names satisfying the regex.</span>
<span class="sd">            For `find_subgraph`, it returns all the subgraphs containing the nodes</span>
<span class="sd">            satisfying the pattern constraints. The outer-most list contains different</span>
<span class="sd">            subgraphs, and the inner list contains the nodes inside a specific subgraph.</span>
<span class="sd">            The inner-most tuple includes the name of the parent module that the node</span>
<span class="sd">            belongs to, and the matched node object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">regex_or_pattern_fn</span><span class="p">,</span> <span class="p">(</span><span class="n">FunctionType</span><span class="p">,</span> <span class="n">Pattern</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_subgraph</span><span class="p">(</span><span class="n">regex_or_pattern_fn</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">regex_or_pattern_fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_node</span><span class="p">(</span><span class="n">regex_or_pattern_fn</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unrecognized pattern type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">regex_or_pattern_fn</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Schedule.trace_until"><a class="viewcode-back" href="../../python_api/schedule.html#slapo.Schedule.trace_until">[docs]</a>    <span class="k">def</span> <span class="nf">trace_until</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A syntax sugar that traces from the top module until the sub-module</span>
<span class="sd">        specified in path, so that we can apply computation optimization, such as</span>
<span class="sd">        cutting pipeline stages at the level.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        paths : Union[str, List[str]]</span>
<span class="sd">            The path to the sub-module that we want to trace until.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Other arguments for `trace` API.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Sanity check.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;trace_until can only be called on the top module&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mod</span><span class="p">,</span> <span class="n">fx</span><span class="o">.</span><span class="n">GraphModule</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Top module has been traced&quot;</span><span class="p">)</span>

        <span class="c1"># Add all child modules to the leaf modules.</span>
        <span class="n">leaf_modules</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">paths</span><span class="p">]:</span>
            <span class="n">leaf_modules</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">path</span><span class="p">]</span><span class="o">.</span><span class="n">child</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="n">tracer</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;tracer&quot;</span><span class="p">,</span> <span class="s2">&quot;pytorch&quot;</span><span class="p">)</span>
        <span class="n">concrete_args</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;concrete_args&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span>
            <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">flatten</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">leaf_modules</span><span class="o">=</span><span class="n">leaf_modules</span><span class="p">,</span>
            <span class="n">tracer</span><span class="o">=</span><span class="n">tracer</span><span class="p">,</span>
            <span class="n">concrete_args</span><span class="o">=</span><span class="n">concrete_args</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">flatten</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mod</span><span class="p">,</span> <span class="n">fx</span><span class="o">.</span><span class="n">GraphModule</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">failed_msg</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">gm</span> <span class="o">=</span> <span class="n">trace_module</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mod</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="n">recursive</span><span class="p">,</span> <span class="n">flatten</span><span class="o">=</span><span class="n">flatten</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="n">failed_msg</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">failed_msg</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gm</span><span class="p">,</span> <span class="n">fx</span><span class="o">.</span><span class="n">GraphModule</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">gm</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;Failed to trace </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">. Please explicitly &quot;</span>
            <span class="s2">&quot;use sch[&#39;</span><span class="si">%s</span><span class="s2">&#39;].trace(...) to provide necessary information. &quot;</span>
            <span class="s2">&quot;If you encounter this error with sch[&#39;</span><span class="si">%s</span><span class="s2">&#39;].trace(...), it is &quot;</span>
            <span class="s2">&quot;either due to the incorrect tracer/concrete args, or the limtation &quot;</span>
            <span class="s2">&quot;in torch.fx.&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
            <span class="s2">&quot;Check the above error messages&quot;</span> <span class="k">if</span> <span class="n">failed_msg</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">failed_msg</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="list_primitives"><a class="viewcode-back" href="../../python_api/schedule.html#slapo.list_primitives">[docs]</a><span class="k">def</span> <span class="nf">list_primitives</span><span class="p">(</span><span class="n">name_only</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;List all available schedule primitives.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name_only : bool</span>
<span class="sd">        If True, only return the name of the primitives. Otherwise, return the</span>
<span class="sd">        primitive class.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Union[list[str], dict[str, Primitive]]</span>
<span class="sd">        If name_only, return a list of all available schedule primitives;</span>
<span class="sd">        otherwise return a dictionary mapping the name of the primitive to the</span>
<span class="sd">        primitive class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">PRIMITIVES</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">if</span> <span class="n">name_only</span> <span class="k">else</span> <span class="n">PRIMITIVES</span></div>


<div class="viewcode-block" id="create_schedule"><a class="viewcode-back" href="../../python_api/schedule.html#slapo.create_schedule">[docs]</a><span class="k">def</span> <span class="nf">create_schedule</span><span class="p">(</span>
    <span class="n">root</span><span class="p">:</span> <span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="n">path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Schedule</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">group</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">dist</span><span class="o">.</span><span class="n">ProcessGroup</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a schedule for the given module and preserve the module hierarchy.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    root : nn.Module</span>
<span class="sd">        The root module to create the schedule for.</span>
<span class="sd">    name : str</span>
<span class="sd">        The name of the module.</span>
<span class="sd">    path : str</span>
<span class="sd">        The path from the top module.</span>
<span class="sd">    parent : Optional[Schedule]</span>
<span class="sd">        The parent schedule. None if the module is the top module.</span>
<span class="sd">    group : Optional[dist.ProcessGroup]</span>
<span class="sd">        The process group for the module. If None, use all available devices.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        Additional arguments for the schedule.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Schedule</span>
<span class="sd">        The schedule for the module.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="n">module</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">module</span><span class="o">.</span><span class="vm">__module__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;torch.nn&quot;</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">module</span><span class="o">.</span><span class="vm">__module__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;torch.ao.nn&quot;</span><span class="p">)</span>
        <span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_module_list</span><span class="p">(</span><span class="n">module</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A module list will become nn.Module or fx.GraphModule after tracing,</span>
<span class="sd">        but we still want to treat it as a module list in the schedule.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">ModuleList</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">fx</span><span class="o">.</span><span class="n">GraphModule</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">mod</span><span class="p">,</span> <span class="n">fx</span><span class="o">.</span><span class="n">GraphModule</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># If the module and its parent are both traced, we can check</span>
            <span class="c1"># the caller in the parent. If there is a caller that directly</span>
            <span class="c1"># calls this module, then this is not a module list.</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">mod</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;call_module&quot;</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">target</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># If all above cannot work, we could only chacke if its children are indexed by</span>
        <span class="c1"># sequential integers, and treat it as a module list if so.</span>
        <span class="n">child_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">named_children</span><span class="p">()]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">child_names</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">child_names</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">child_names</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">child_names</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">child_names</span><span class="p">)))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="n">root_sch</span> <span class="o">=</span> <span class="n">Schedule</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_leaf</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">root_sch</span>

    <span class="n">child_schedules</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">child_name</span><span class="p">,</span> <span class="n">submod</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">named_children</span><span class="p">():</span>
        <span class="n">next_path</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">child_name</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">path</span> <span class="k">else</span> <span class="n">child_name</span>
        <span class="k">if</span> <span class="n">is_module_list</span><span class="p">(</span><span class="n">submod</span><span class="p">):</span>
            <span class="c1"># We assume ModuleList will be iteratively traversed in forward function.</span>
            <span class="c1"># For example:</span>
            <span class="c1"># In __init__: self.layers = nn.ModuleList([nn.Linear(10, 10) for _ in range(3)])</span>
            <span class="c1"># In forwrad :</span>
            <span class="c1">#     for layer in self.layers:</span>
            <span class="c1">#         x = layer(x)</span>
            <span class="c1"># In this case, we register submodule as layer.0, layer.1, etc.</span>
            <span class="k">for</span> <span class="n">name_idx</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">submod</span><span class="o">.</span><span class="n">named_children</span><span class="p">():</span>
                <span class="n">child_schedules</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">child_name</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">name_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_schedule</span><span class="p">(</span>
                    <span class="n">layer</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">child_name</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">name_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">next_path</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">name_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">root_sch</span><span class="p">,</span>
                    <span class="n">group</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For other submodules including nn.Sequential, we assume they are directly</span>
            <span class="c1"># called in forward function. For example:</span>
            <span class="c1"># In __init__: self.block = nn.Sequential(...)</span>
            <span class="c1"># In forward : out = self.block(x)</span>
            <span class="c1"># In this case, fx IR will create directly call the submodule such as block.</span>
            <span class="n">child_schedules</span><span class="p">[</span><span class="n">child_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_schedule</span><span class="p">(</span>
                <span class="n">submod</span><span class="p">,</span> <span class="n">child_name</span><span class="p">,</span> <span class="n">next_path</span><span class="p">,</span> <span class="n">root_sch</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

    <span class="n">root_sch</span><span class="o">.</span><span class="n">child</span> <span class="o">=</span> <span class="n">child_schedules</span>
    <span class="k">return</span> <span class="n">root_sch</span></div>
</pre></div>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Amazon
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
       Copyright 2023, Amazon.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>